<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Arbitrary R/W</title><link href="https://josiahpierce.github.io/" rel="alternate"></link><link href="https://josiahpierce.github.io/feeds/all.atom.xml" rel="self"></link><id>https://josiahpierce.github.io/</id><updated>2021-01-09T00:00:00-05:00</updated><entry><title>JavaScript Engine Exploitation: Study Session 1</title><link href="https://josiahpierce.github.io/javascript-engine-exploitation-study-session-1.html" rel="alternate"></link><published>2021-01-09T00:00:00-05:00</published><updated>2021-01-09T00:00:00-05:00</updated><author><name>Josiah Pierce</name></author><id>tag:josiahpierce.github.io,2021-01-09:/javascript-engine-exploitation-study-session-1.html</id><summary type="html">&lt;p&gt;Part 1 of a series of writeups on resources for learning JavaScript Engine Exploitation&lt;/p&gt;</summary><content type="html">&lt;p&gt;To continue this series of summaries of various resources on JS engine exploitation, I decided to watch one of many outstanding talks by &lt;a href="https://twitter.com/natashenka"&gt;Natalie Silvanovich&lt;/a&gt; of Project Zero. She has multiple talks on attacking ECMAScript engines, but I started with this one entitled "Attacking ECMAScript Engines with Redefinition":&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/KT2vYWcwj-w" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;As with all posts in this series, please keep in mind that this is only a summary of the points I found most useful. I highly recommend following along with the video to see all the examples and get full context.&lt;/p&gt;
&lt;h4&gt;Technical details&lt;/h4&gt;
&lt;p&gt;In the context of the presentation, "redefinition" means changing something with an understood meaning in ECMAScript standards to mean something else. For example, in the first code snippet of the presentation, the function &lt;code&gt;alert()&lt;/code&gt; is redefined to be equal to a different function, as seen in the following line:
&lt;code&gt;alert = f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In the case illustrated in the presentation, calling &lt;code&gt;alert()&lt;/code&gt; now calls the function &lt;code&gt;f()&lt;/code&gt;, rather than the built-in &lt;code&gt;alert()&lt;/code&gt; function most of us are probably familiar with that creates a pop-up message.&lt;/p&gt;
&lt;p&gt;However, in some cases, there's also the possiblity that the redefintion doesn't override the original definition -- meaning the original definition gets used anyway. The final side case is that execution just fails entirely, meaning that neither the original nor the updated definition will be used.&lt;/p&gt;
&lt;p&gt;One way to perform redefinition, as seen in that first example, is to use the equality operator "=".  In JavaScript specifically, Natalie mentions that one native method can be redefined as another native method, but this can't be done directly. Instead, a wrapper needs to be placed around the second native method (as seen where &lt;code&gt;alert()&lt;/code&gt; is redefined to &lt;code&gt;f()&lt;/code&gt;, which in the example was just a wrapper around &lt;code&gt;document.write()&lt;/code&gt; -- note that the example isn't simply setting &lt;code&gt;alert()&lt;/code&gt; to &lt;code&gt;document.write()&lt;/code&gt; directly).&lt;/p&gt;
&lt;p&gt;The first example that the talk provides of abusing redefinition with the equality operator is to set up a type confusion. After instantiating an object, the constructor for the object is then redefined to be a different constructor. If my understanding is correct, later on in the code, some content from that object gets copied into a temporary array and a new object is created to point to it. However, the new object is created using the redefined constructor. Since it's been redefined, the code thinks it's using the right constructor, but really it's using a different one that will create a different object, leading to a type confusion.&lt;/p&gt;
&lt;p&gt;Basically, the simplified idea here seems to be to find some constructor, redefine it to be a different constructor of some useful type, and then call a function that will create an object using the original constructor without realizing that the constructor has been redefined. This means it'll instantiate an object of a type other than the one it was expecting.&lt;/p&gt;
&lt;p&gt;Natalie then covers another way to perform redefinition -- proxy objects. Proxy objects could be leveraged to change the methods within an object that end up being called, or change the results that are provided based on how many times the proxy object has been enumerated before. This concept is only briefly covered, but it's inspired me to do more research into Proxy objects and find some good example bugs. Here's one by Saelo from Pwn2Own 2018 that uses a Proxy object to create side effects that the JIT compiler doesn't consider:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/saelo/pwn2own2018#stage-0"&gt;https://github.com/saelo/pwn2own2018#stage-0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Yet another redefinition idea is to use conversion operators such as valueOf and toString. The example I immediately thought of for using valueOf was this paper by Saelo, which covers a bug in JavaScriptCore (JSC): 
&lt;a href="http://phrack.org/papers/attacking_javascript_engines.html"&gt;http://phrack.org/papers/attacking_javascript_engines.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Basically, when an object is converted to an integer, if the object has a valueOf property, its return value can be used as the result of the integer conversion. The valueOf property can contain an inline function that peforms additional operations besides just returning an integer; for example, it could change the length property of an array, causing an unexpected side effect (definitely check out Saelo's Phrack paper I linked above; it's got a great illustration of this for getting OOB array access).&lt;/p&gt;
&lt;p&gt;There's a discussion of “watches”, which sound sort of like getters/setters. I'll skip over this portion of the talk, because at least in Firefox, it appears that watches have been deprecated and removed, according to this documentation: &lt;a href="https://developer.mozilla.org/en-US/docs/Archive/Web/JavaScript/Object.watch"&gt;https://developer.mozilla.org/en-US/docs/Archive/Web/JavaScript/Object.watch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There's also some discussion of some methods that could theoretically be used for redefinition attacks, but didn't have specific bug examples. Since this talk is from 2015, I'll have to keep these in mind and research whether any of them did indeed end up being possible to leverage for redefinition attacks. &lt;/p&gt;
&lt;p&gt;Finally, there's a brief overview of how to hunt for these types of bugs. I'm primarily interested in finding bugs through source code review, so I'll ignore the portions on fuzzing and reverse engineering (as the targets I'm interested in attacking are open source).&lt;/p&gt;
&lt;p&gt;The two methods that are relevant to my interests are code review and API docs. For code review, Natalie says to hunt for functions that peform calls that allow script execution, and then look for vulnerabilities there. If API docs are available, she suggests looking for functions that take objects or arrays as parameters, because the objects or elements in the array need to be converted to another type, which might in turn mean that calls to valueOf or toString will be performed.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;This talk provided a nice overview of some methods of performing redefinition attacks. In particular, it's encouraged me to look into using Proxy objects for exploitation, which is something I was vaguely aware of prior to watching this talk, but had never investigated.&lt;/p&gt;</content><category term="articles"></category><category term="study"></category><category term="javascript_engine"></category><category term="exploitation"></category></entry><entry><title>JavaScript Engine Exploitation: Study Session 0</title><link href="https://josiahpierce.github.io/javascript-engine-exploitation-study-session-0.html" rel="alternate"></link><published>2021-01-01T00:00:00-05:00</published><updated>2021-01-01T00:00:00-05:00</updated><author><name>Josiah Pierce</name></author><id>tag:josiahpierce.github.io,2021-01-01:/javascript-engine-exploitation-study-session-0.html</id><summary type="html">&lt;p&gt;Part 0 of a series of writeups on resources for learning JavaScript Engine Exploitation&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've been interested in JavaScript engine exploitation and browser exploitation for a while now. While I've spent some time studying this topic and performing vulnerability research on JS engines on and off, I feel I haven't really applied myself to focused, consistent study. As a result, I'll occasionally spend a weekend  poring over some resources and auditing a little code, then take a long break and promptly forget most of what I learned. &lt;/p&gt;
&lt;p&gt;In an attempt to remediate that behavior, I'm kicking this blog off with a series of "study sessions" on various JavaScript engine exploitation writeups and presentations. Every two weeks, I plan to spend time reading or watching a resource on JS engine exploitation or internals and then writing up a summary of the resource and what I learned. Ideally, this will encourage me to consistently engage with new material and understand it well enough to be able to explain some of the key points here. I'll continue this series until I feel I've consumed and summarized a reasonable corpus of learning resources.&lt;/p&gt;
&lt;p&gt;Hopefully, other readers will find these summaries valuable as quick references and as encouragement to study the full versions of these resources themselves.&lt;/p&gt;
&lt;p&gt;There's certainly no shortage of resources to choose from; if you'd like to find some to study for yourself, there's an excellent list here:
&lt;a href="https://zon8.re/posts/javascript-engine-fuzzing-and-exploitation-reading-list/"&gt;https://zon8.re/posts/javascript-engine-fuzzing-and-exploitation-reading-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I'm primarily interested in attacking Firefox, which uses the Spidermonkey JS engine. It's where I've spent the most time, and most of the resources I cover will be at least partially aimed at Firefox. However, I also have an interest in Chrome (which uses the V8 JS engine). Some resources are also generic enough that even if they cover a different JS engine, they're still valuable and offer useful insight into general vulnerability research or exploitation methods.&lt;/p&gt;
&lt;p&gt;For this first study session, I took a look at this excellent talk by &lt;a href="https://twitter.com/maxpl0it"&gt;@maxpl0it&lt;/a&gt; entitled "Actions Speak Browser Than Words (Exploiting n-days for fun and profit)":&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/L7aiFKDg0Jk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;The talk is aimed at folks new to browser exploitation. Writing n-day exploits based on CVE descriptions or other details is often mentioned as a good way to hone one's exploit development skills, so this talk seemed like a good starting point. The first bug the talk covers is a bug in Internet Explorer (which uses the JScript JS engine), and the second bug is in Firefox. Since I'm less interested in IE, I'll still cover general takeaways from that section, but won't cover as many IE-specific technical details.&lt;/p&gt;
&lt;p&gt;In an effort to avoid simply reproducing the entire contents of the study resource in each post for this series, I'll cover the portions I found most interesting or useful, and reproduce code where necessary. If you want more context, be sure to check out the resource for yourself.&lt;/p&gt;
&lt;h4&gt;Non-technical takeaways&lt;/h4&gt;
&lt;p&gt;There were two particularly useful takeaways in this talk that weren't related to specific technical details:&lt;/p&gt;
&lt;p&gt;-People are often intimidated by large, complex targets because they feel they need to learn all of the internals of the target before they can hunt for bugs. Max mentions that it's possible to proficiently bug hunt without needing to know everything about a target's internals; knowing 40% of the internals could be enough. He also mentions that it becomes easier to expand on your knowledge once you have an understanding of some of the internals. &lt;/p&gt;
&lt;p&gt;-Both of the analyzed vulnerabilities were variants of older bugs. This reinforces something I've heard lots of vulnerability researchers say, which is that a good method for finding new bugs is to look at locations which have had lots of bugs in the past and search for slight variations on those bugs. Sometimes old bugs can even be reintroduced through some regression years after the original issues were fixed. To me, this stresses that it's important to study bugs in components you're interested in attacking, since it helps with pattern recognition. I imagine it's also helpful to know the general exploitation algorithms for previous bugs, since they may largely apply to new bugs that are variants on older ones.&lt;/p&gt;
&lt;h4&gt;Technical details&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;The IE bug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The IE vulnerability was a use-after-free (UAF) due to improper garbage collection. To track down the specific patch that corrected the vulnerability, Max performed binary diffing to identify changed locations. Upon identifying a specific object and function call that appeared to be added in the patched version, he ran a proof-of-concept code snippet on the patched version and used a debugger to skip over the function he believed had been added to patch the issue. Skipping over the function caused a crash, verifying that this was indeed the patch for the issue.&lt;/p&gt;
&lt;p&gt;The idea of just using a debugger to skip over suspected patch code sounds obvious to me now, but I'd actually never used that method before. It's a cool trick to be aware of; it helps provide an option for dynamic analysis if static binary diffing alone isn't enough to be certain whether the patch has been identified.&lt;/p&gt;
&lt;p&gt;Since I'm not super interested in attacking IE myself, I haven't spent further time digging into the JScript internals. However, the general exploitation steps for obtaining some useful primitives are worth noting. My (potentially wrong) understanding of the bug is that the garbage collector doesn't correctly track arguments passed to the &lt;code&gt;Array.prototype.sort()&lt;/code&gt; function. Therefore, the garbage collector doesn't realize that objects referenced by those arguments are still in use. It goes ahead and &lt;code&gt;free()&lt;/code&gt;s the objects, meaning that the arguments are now stale pointers. Any deferencing of those stale pointers should now trigger the UAF.&lt;/p&gt;
&lt;p&gt;The first general exploitation steps are to create lots of these untracked arguments, then manually call the garbage collector (which is possible in JScript). This causes the arguments to become stale pointers, since the objects they were pointing to were freed. Then new allocations are peformed that should re-use the available space the free objects were occupying. By allocating something of a different type than the original objects the arguments pointed to, it's possible to construct a type confusion bug.&lt;/p&gt;
&lt;p&gt;From that point forward, grasping the JScript internals seems to be more important for following along with the rest of the exploit. However, I thought just seeing those first steps broken down was helpful. I haven't looked at a browser bug related to garbage collection before, so this was a nice intro.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Firefox bug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The Firefox vulnerability was a bug in the just in time (JIT) compiler. JIT compilers seem to be one of the most popular components for vulnerability researchers to audit these days (understandably, since they're extremely complex and therefore provide fertile ground for bugs). I'm generally more interested in bugs that are purely in the primary JS engine and not the JIT compiler (especially since not all JS engines feature JIT compilers at all -- smaller engines such as ones used on embedded devices may not have them, for example). However, I thought this was a good introduction to JIT bugs, and covers a nice method of leveraging a JS setter while bypassing a check to ensure an argument is an integer.&lt;/p&gt;
&lt;p&gt;Like most JIT bugs I've seen, this bug was due to optimizing out a specific check while failing to account for potential side effects. You should really check out the presentation if you want to see the full details, but the part that was most interesting to me was the method of triggering the side effect.&lt;/p&gt;
&lt;p&gt;A common method I've seen in JS engine exploitation is to use a setter (code that's called when a property is assigned) or getter (code that's called when a property is accessed) to run some code and make an unexpected change. For example, a getter might change the length of an array during the execution of a loop, causing the loop to go out-of-bounds.&lt;/p&gt;
&lt;p&gt;For example, here's a snippet of code taken from the presentation showing a setter being created for the property "a" for an array:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;let arr = [1,2,3]&lt;/span&gt;
&lt;span class="err"&gt;arr.__defineSetter__(&amp;quot;a&amp;quot;,function(x){&lt;/span&gt;
&lt;span class="err"&gt;    console.log(&amp;quot;Reached!&amp;quot;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this example, an array is created, and then a setter is created for that array. If the property "a" is assigned to the array, the inlined function called "x" will be run, which in this case just prints the message "Reached!" to the console. However, it could do something else, like changing the length of the array, which might cause out-of-bounds access during the execution of whatever function triggered this setter (spoilers: this is exactly what the exploit does).&lt;/p&gt;
&lt;p&gt;However, if my understanding is correct, one additional wrinkle for this bug was that to trigger the vulnerable JIT node, an index of type int32 was required. However, the setter needed to be triggered on a property, not an element. Therefore, the chosen argument for the function was -1, which is still an int32, but won't be considered an element in an array (because it's a negative integer); instead, -1 will be considered a &lt;em&gt;property&lt;/em&gt;, triggering the setter. It's a clever method of working around several constraints.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;Even though this talk covered areas that aren't my primary interest (JScript and JIT bugs), I still felt it was well worth the time investment to watch. There were good technical and non-technical takeaways, and it was nice to start with a resource aimed at newcomers to browser exploitation.&lt;/p&gt;</content><category term="articles"></category><category term="study"></category><category term="javascript_engine"></category><category term="exploitation"></category></entry></feed>